#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <VectorXf.h>

#include "MPU6500_Raw.h"
MPU6500 mpu;



#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
#define SCREEN_ADDRESS 0x3C

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire1, OLED_RESET);

uint32_t interval, last_cycle;
uint32_t loop_micros;
uint32_t cycle_count;

void dot(int x, int y, int r) {
  if (r < 1) r = 1;
  display.fillCircle(x, y, r, SSD1306_WHITE);
}
// Draw n dice (1–4)
void draw(uint8_t n, uint8_t faces) {
  display.clearDisplay();
  int values=0;
  int diceSize = 20;
  int spacing = diceSize + 4;
  int cols = min(n, 2);
  int rows = (n + 1) / 2;

  int startX = (SCREEN_WIDTH - cols * spacing + 4) / 2;
  int startY = (SCREEN_HEIGHT - rows * spacing + 4) / 2;

  for (int i = 0; i < n; i++) {
    int col = i % 2;
    int row = i / 2;
    int x0 = startX + col * spacing;
    int y0 = startY + row * spacing;

    int cx = x0 + diceSize / 2;
    int cy = y0 + diceSize / 2;
    int offset = diceSize / 4;
    int dotRadius = diceSize / 10;

    int value = random(1, faces + 1);
    Serial.print("Die "); Serial.print(i + 1);
    Serial.print(": value="); Serial.println(value);

    // --- CASE 1: D4 (triangular) ---
    if (faces == 4) {
      // Draw triangle (like a d4)
      int half = diceSize / 2;
      int topX = cx;
      int topY = y0;
      int leftX = x0;
      int leftY = y0 + diceSize;
      int rightX = x0 + diceSize;
      int rightY = y0 + diceSize;

      display.drawLine(leftX, leftY, topX, topY, SSD1306_WHITE);
      display.drawLine(topX, topY, rightX, rightY, SSD1306_WHITE);
      display.drawLine(rightX, rightY, leftX, leftY, SSD1306_WHITE);

      // Display the rolled number inside
      display.setTextSize(1);
      display.setTextColor(SSD1306_WHITE);
      display.setCursor(cx - 2, cy - 1);
      display.print(value);
      values=values+value;

    }
    // --- CASE 2: Standard 6-sided or higher ---
    else {
      // Draw square die
      display.drawRect(x0, y0, diceSize, diceSize, SSD1306_WHITE);

      if (faces > 6) 
      {
        // Display number if above 6
        display.setTextSize(1);
        display.setTextColor(SSD1306_WHITE);

        // Measure approximate text width (each character ≈ 6 pixels wide at size 1)
        int textWidth = String(value).length() * 6;
        int textHeight = 8; // standard font height

        // Compute centered cursor position
        int textX = cx - textWidth / 2;
        int textY = cy - textHeight / 2;

        display.setCursor(textX, textY);
        display.print(value);
        values=values+value;

      }
      else {
        // Draw dots (standard die)
        switch (value) {
          case 1:
            dot(cx, cy, dotRadius);
            values=values+value;
            break;
          case 2:
            dot(x0 + offset, y0 + offset, dotRadius);
            dot(x0 + diceSize - offset, y0 + diceSize - offset, dotRadius);
            values=values+value;
            break;
          case 3:
            dot(cx, cy, dotRadius);
            dot(x0 + offset, y0 + offset, dotRadius);
            dot(x0 + diceSize - offset, y0 + diceSize - offset, dotRadius);
            values=values+value;
            break;
          case 4:
            dot(x0 + offset, y0 + offset, dotRadius);
            dot(x0 + diceSize - offset, y0 + offset, dotRadius);
            dot(x0 + offset, y0 + diceSize - offset, dotRadius);
            dot(x0 + diceSize - offset, y0 + diceSize - offset, dotRadius);
            values=values+value;
            break;
          case 5:
            dot(cx, cy, dotRadius);
            dot(x0 + offset, y0 + offset, dotRadius);
            dot(x0 + diceSize - offset, y0 + offset, dotRadius);
            dot(x0 + offset, y0 + diceSize - offset, dotRadius);
            dot(x0 + diceSize - offset, y0 + diceSize - offset, dotRadius);
            values=values+value;
            break;
          case 6:
            dot(x0 + offset, y0 + offset, dotRadius);
            dot(x0 + diceSize - offset, y0 + offset, dotRadius);
            dot(x0 + offset, cy, dotRadius);
            dot(x0 + diceSize - offset, cy, dotRadius);
            dot(x0 + offset, y0 + diceSize - offset, dotRadius);
            dot(x0 + diceSize - offset, y0 + diceSize - offset, dotRadius);
            values=values+value;
            break;
        }
      }
    }
  }
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0,55);
  display.printf("Sum of the values:");
  display.println(values);
  display.display();
}


// Draw dots for a D6 dice face




void set_interval(float new_interval)
{
  interval = new_interval * 1000000L;   // In microseconds
}  


// Struct to store IMU readings
typedef struct 
{
  Vec3f w;
  Vec3f a;
  uint32_t cycle_time, last_cycle_time; // IMU cycle tracking
} imu_values_t;
imu_values_t imu;


enum {
  fsm_start = 0,
  fsm_detect = 1,
  fsm_roll = 2,
};

typedef struct {
  int state;
  unsigned long tes;  // Time entering state
  int movement_count; // Count consecutive movement cycles
} fsm_t;

fsm_t fsm1;

void set_state(fsm_t &fsm, int new_state) {
  if (fsm.state != new_state) {
    fsm.state = new_state;
    fsm.tes = millis();
    fsm.movement_count = 0; // reset counter on state change
  }
}

void setup()
{
    Serial.begin(115200);
    randomSeed(analogRead(0));
    const int I2C1_SDA = 18;
    const int I2C1_SCL = 19;
    pinMode(I2C1_SDA, INPUT_PULLUP);
    pinMode(I2C1_SCL, INPUT_PULLUP);
    Wire1.setSDA(I2C1_SDA);
    Wire1.setSCL(I2C1_SCL);
    Wire1.begin();
    Wire1.setClock(400000);

    while (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) 
    {
    Serial.println("SSD1306 allocation failed");
    delay(500);
    }

    display.display();
    delay(1000);
    display.clearDisplay();
    
    // Our cycle time
    set_interval(20e-3); // 20 ms -> 50 Hz

    const int I2C0_SDA = 20;
    const int I2C0_SCL = 21;
    pinMode(I2C0_SDA, INPUT_PULLUP);
    pinMode(I2C0_SCL, INPUT_PULLUP);
  
    Wire.setSDA(I2C0_SDA);
    Wire.setSCL(I2C0_SCL);
    Wire.begin();
  
    delay(20);
  
    MPU6500Setting setting;
    setting.accel_fs_sel = ACCEL_FS_SEL::A16G;
    setting.gyro_fs_sel = GYRO_FS_SEL::G2000DPS;
    setting.fifo_sample_rate = FIFO_SAMPLE_RATE::SMPL_200HZ;
    setting.gyro_fchoice = 0x03;
    setting.gyro_dlpf_cfg = GYRO_DLPF_CFG::DLPF_41HZ;
    setting.accel_fchoice = 0x01;
    setting.accel_dlpf_cfg = ACCEL_DLPF_CFG::DLPF_45HZ;
  
    while (!mpu.setup(0x68, setting)) 
    { 
        Serial.println("MPU connection failed.");
        delay(500); // Wait to try again     
    }

    set_state(fsm1,fsm_start);
    long b=mpu.getGyroZ();
    Serial.print(b);
}





void loop()
{
  uint32_t now = micros();
  uint32_t delta = now - last_cycle;

  if (delta >= interval) {
    last_cycle = now;
    cycle_count++;

    if (mpu.update()) {
      imu.last_cycle_time = imu.cycle_time;
      imu.cycle_time = micros();

      imu.w.x = mpu.getGyroX();
      imu.w.y = mpu.getGyroY();
      imu.w.z = mpu.getGyroZ();
      imu.a.x = mpu.getAccX();
      imu.a.y = mpu.getAccY();
      imu.a.z = mpu.getAccZ();
    }

    // ======= FSM Logic =======
    float ax = imu.a.x;
    float ay = imu.a.y;
    bool moving = (fabs(ax) > 0.5 || fabs(ay) > 0.5);

    switch (fsm1.state) {

      case fsm_start:
        if (moving) {
          Serial.println("Movement detected -> fsm_detect");
          set_state(fsm1, fsm_detect);
        }
        break;

      case fsm_detect:
        if (moving) {
          fsm1.movement_count++;
          Serial.printf("Movement cycle %d\n", fsm1.movement_count);
          if (fsm1.movement_count >= 3) {
            Serial.println("3 cycles of movement -> fsm_roll");
            set_state(fsm1, fsm_roll);
          }
        } else {
          Serial.println("Movement stopped -> fsm_start");
          set_state(fsm1, fsm_start);
        }
        break;

      case fsm_roll:
        {
          uint8_t diceCount = random(1, 5);
          Serial.printf("Rolling %d dice...\n", diceCount);
          draw(diceCount,6);
          delay(1000);

          Serial.println("Returning to start state");

          set_state(fsm1, fsm_start);
        }
        break;
    }

    // ======= Display IMU data =======
    /*display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0, 0);
    display.printf("Ax %.2f\nAy %.2f\nAz %.2f", imu.a.x, imu.a.y, imu.a.z);
    display.display();

    // Serial output
    Serial.printf("IMU_dt %d; Wx %.2f; Wy %.2f; Wz %.2f; Ax %.2f; Ay %.2f; Az %.2f\n",
      imu.cycle_time - imu.last_cycle_time,
      imu.w.x, imu.w.y, imu.w.z,
      imu.a.x, imu.a.y, imu.a.z
    );*/
  }
}
